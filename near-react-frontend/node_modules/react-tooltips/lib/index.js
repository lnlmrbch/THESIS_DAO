'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ReactDOM = _interopDefault(require('react-dom'));
var ExecutionEnvironment = _interopDefault(require('exenv'));
var is = _interopDefault(require('is-lite'));
var React = _interopDefault(require('react'));
var PropTypes = _interopDefault(require('prop-types'));
var isRequiredIf = _interopDefault(require('react-proptype-conditional-require'));
var Popper = _interopDefault(require('popper.js'));
var deepmerge = _interopDefault(require('deepmerge'));

var DEFAULTS = {
  flip: {
    padding: 20
  },
  preventOverflow: {
    padding: 10
  }
};

var STATUS = {
  INIT: 'init',
  IDLE: 'idle',
  OPENING: 'opening',
  OPEN: 'open',
  CLOSING: 'closing',
  ERROR: 'error'
};

var canUseDOM = ExecutionEnvironment.canUseDOM;

var isReact16 = ReactDOM.createPortal !== undefined;

function comparator(data, nextData) {
  return {
    changedFrom: function changedFrom(key, previous, actual) {
      return data[key] === previous && nextData[key] === actual;
    },
    changedTo: function changedTo(key, actual) {
      return data[key] !== actual && nextData[key] === actual;
    },
    changed: function changed(key) {
      return data[key] !== nextData[key];
    }
  };
}

function isMobile() {
  return 'ontouchstart' in window && /Mobi/.test(navigator.userAgent);
}

/**
 * Log method calls if debug is enabled
 *
 * @private
 * @param {Object}       arg
 * @param {string}       arg.title    - The title the logger was called from
 * @param {Object|Array} [arg.data]   - The data to be logged
 * @param {boolean}      [arg.warn]  - If true, the message will be a warning
 * @param {boolean}      [arg.debug] - Nothing will be logged unless debug is true
 */
function log(_ref) {
  var title = _ref.title,
      data = _ref.data,
      _ref$warn = _ref.warn,
      warn = _ref$warn === undefined ? false : _ref$warn,
      _ref$debug = _ref.debug,
      debug = _ref$debug === undefined ? false : _ref$debug;

  /* eslint-disable no-console */
  var logFn = warn ? console.warn || console.error : console.log;

  if (debug && title && data) {
    console.groupCollapsed('%creact-tooltips: ' + title, 'color: #9b00ff; font-weight: bold; font-size: 12px;');

    if (Array.isArray(data)) {
      data.forEach(function (d) {
        if (is.plainObject(d) && d.key) {
          logFn.apply(console, [d.key, d.value]);
        } else {
          logFn.apply(console, [d]);
        }
      });
    } else {
      logFn.apply(console, [data]);
    }

    console.groupEnd();
  }
  /* eslint-enable */
}

function on(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  element.addEventListener(event, cb, capture);
}

function off(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  element.removeEventListener(event, cb, capture);
}

function once(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var _nextCB = void 0;

  _nextCB = function nextCB(e) {
    //eslint-disable-line prefer-const
    cb(e);
    off(element, event, _nextCB);
  };

  on(element, event, _nextCB, capture);
}

function noop() {}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Portal = function (_React$Component) {
  inherits(Portal, _React$Component);

  function Portal(props) {
    classCallCheck(this, Portal);

    var _this = possibleConstructorReturn(this, (Portal.__proto__ || Object.getPrototypeOf(Portal)).call(this, props));

    if (!canUseDOM) return possibleConstructorReturn(_this);

    _this.node = document.createElement('div');
    _this.node.style.zIndex = 1;
    if (props.id) {
      _this.node.id = props.id;
    }

    document.body.appendChild(_this.node);
    return _this;
  }

  createClass(Portal, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!canUseDOM) return;

      if (!isReact16) {
        this.renderPortal();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (!canUseDOM) return;

      var _props = this.props,
          placement = _props.placement,
          status = _props.status;


      if (!isReact16 && (prevProps.status !== status || prevProps.placement !== placement)) {
        this.renderPortal();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (!canUseDOM || !this.node) return;

      if (!isReact16) {
        ReactDOM.unmountComponentAtNode(this.node);
      }

      document.body.removeChild(this.node);
    }
  }, {
    key: 'renderPortal',
    value: function renderPortal() {
      if (!canUseDOM) return null;

      var _props2 = this.props,
          children = _props2.children,
          setRef = _props2.setRef;

      /* istanbul ignore else */

      if (isReact16) {
        return ReactDOM.createPortal(children, this.node);
      }

      var portal = ReactDOM.unstable_renderSubtreeIntoContainer(this, children.length > 1 ? React.createElement(
        'div',
        null,
        children
      ) : children[0], this.node);

      setRef(portal);

      return null;
    }
  }, {
    key: 'renderReact16',
    value: function renderReact16() {
      var _props3 = this.props,
          hasChildren = _props3.hasChildren,
          placement = _props3.placement,
          target = _props3.target;


      if (!hasChildren) {
        if (target || placement === 'center') {
          return this.renderPortal();
        }

        return null;
      }

      return this.renderPortal();
    }
  }, {
    key: 'render',
    value: function render() {
      if (!isReact16) {
        return null;
      }

      return this.renderReact16();
    }
  }]);
  return Portal;
}(React.Component);

Portal.propTypes = {
  children: PropTypes.oneOfType([PropTypes.element, PropTypes.array]),
  hasChildren: PropTypes.bool,
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  placement: PropTypes.string,
  setRef: PropTypes.func.isRequired,
  status: PropTypes.string,
  target: PropTypes.oneOfType([PropTypes.object, PropTypes.string])
};

var Arrow = function (_React$Component) {
  inherits(Arrow, _React$Component);

  function Arrow() {
    classCallCheck(this, Arrow);
    return possibleConstructorReturn(this, (Arrow.__proto__ || Object.getPrototypeOf(Arrow)).apply(this, arguments));
  }

  createClass(Arrow, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          placement = _props.placement,
          setArrowRef = _props.setArrowRef,
          styles = _props.styles;
      var _styles$arrow = styles.arrow,
          color = _styles$arrow.color,
          display = _styles$arrow.display,
          length = _styles$arrow.length,
          position = _styles$arrow.position,
          spread = _styles$arrow.spread;

      var arrowStyles = { display: display, position: position };

      var points = void 0;
      var x = spread;
      var y = length;

      /* istanbul ignore else */
      if (placement.startsWith('top')) {
        points = '0,0 ' + x / 2 + ',' + y + ' ' + x + ',0';
        arrowStyles.bottom = -y;
      } else if (placement.startsWith('bottom')) {
        points = x + ',' + y + ' ' + x / 2 + ',0 0,' + y;
        arrowStyles.top = 0;
      } else if (placement.startsWith('left')) {
        y = spread;
        x = length;
        points = '0,0 ' + x + ',' + y / 2 + ' 0,' + y;
        arrowStyles.right = 0;
      } else if (placement.startsWith('right')) {
        y = spread;
        x = length;
        points = x + ',' + y + ' ' + x + ',0 0,' + y / 2;
        arrowStyles.left = 0;
      }

      return React.createElement(
        'div',
        {
          className: '__tooltip__arrow',
          style: this.arrowStyle
        },
        React.createElement(
          'span',
          { ref: setArrowRef, style: arrowStyles },
          React.createElement(
            'svg',
            {
              width: x,
              height: y,
              version: '1.1',
              xmlns: 'http://www.w3.org/2000/svg'
            },
            React.createElement('polygon', { points: points, fill: color })
          )
        )
      );
    }
  }, {
    key: 'arrowStyle',
    get: function get$$1() {
      var _props2 = this.props,
          placement = _props2.placement,
          styles = _props2.styles;
      var length = styles.arrow.length;

      var arrow = {
        position: 'absolute'
      };

      /* istanbul ignore else */
      if (placement.startsWith('top')) {
        arrow.bottom = length;
        arrow.left = 0;
        arrow.right = 0;
      } else if (placement.startsWith('bottom')) {
        arrow.top = 0;
        arrow.left = 0;
        arrow.right = 0;
      } else if (placement.startsWith('left')) {
        arrow.right = 0;
        arrow.top = 0;
        arrow.bottom = 0;
      } else if (placement.startsWith('right')) {
        arrow.left = 0;
        arrow.top = 0;
      }

      return arrow;
    }
  }]);
  return Arrow;
}(React.Component);

Arrow.propTypes = {
  placement: PropTypes.string.isRequired,
  setArrowRef: PropTypes.func.isRequired,
  styles: PropTypes.object.isRequired
};

var CloseBtn = function CloseBtn(_ref) {
  var handleClick = _ref.handleClick,
      styles = _ref.styles;
  var color = styles.color,
      height = styles.height,
      width = styles.width,
      style = objectWithoutProperties(styles, ['color', 'height', 'width']);


  return React.createElement(
    'button',
    { 'aria-label': 'close', style: style, onClick: handleClick },
    React.createElement(
      'svg',
      {
        width: width + 'px',
        height: height + 'px',
        viewBox: '0 0 18 18',
        version: '1.1',
        xmlns: 'http://www.w3.org/2000/svg',
        preserveAspectRatio: 'xMidYMid'
      },
      React.createElement(
        'g',
        null,
        React.createElement('path', {
          d: 'M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z',
          fill: color
        })
      )
    )
  );
};

CloseBtn.propTypes = {
  handleClick: PropTypes.func.isRequired,
  styles: PropTypes.object.isRequired
};

var TooltipContainer = function TooltipContainer(_ref) {
  var content = _ref.content,
      footer = _ref.footer,
      handleClick = _ref.handleClick,
      open = _ref.open,
      positionWrapper = _ref.positionWrapper,
      showCloseButton = _ref.showCloseButton,
      title = _ref.title,
      styles = _ref.styles;

  var output = {
    content: React.isValidElement(content) ? content : React.createElement(
      'div',
      { className: '__tooltip__content', style: styles.content },
      content
    )
  };

  if (title) {
    output.title = React.isValidElement(title) ? title : React.createElement(
      'div',
      { className: '__tooltip__title', style: styles.title },
      title
    );
  }

  if (footer) {
    output.footer = React.isValidElement(footer) ? footer : React.createElement(
      'div',
      { className: '__tooltip__footer', style: styles.footer },
      footer
    );
  }

  if ((showCloseButton || positionWrapper) && !is.boolean(open)) {
    output.close = React.createElement(CloseBtn, {
      styles: styles.close,
      handleClick: handleClick
    });
  }
  return React.createElement(
    'div',
    { className: '__tooltip__container', style: styles.container },
    output.close,
    output.title,
    output.content,
    output.footer
  );
};

TooltipContainer.propTypes = {
  content: PropTypes.node.isRequired,
  footer: PropTypes.node,
  handleClick: PropTypes.func.isRequired,
  open: PropTypes.bool,
  positionWrapper: PropTypes.bool.isRequired,
  showCloseButton: PropTypes.bool.isRequired,
  styles: PropTypes.object.isRequired,
  title: PropTypes.node
};

var Tooltip = function (_React$Component) {
  inherits(Tooltip, _React$Component);

  function Tooltip() {
    classCallCheck(this, Tooltip);
    return possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).apply(this, arguments));
  }

  createClass(Tooltip, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          component = _props.component,
          closeTooltip = _props.handleClick,
          hideArrow = _props.hideArrow,
          setTooltipRef = _props.setTooltipRef;


      var output = {};

      if (component) {
        if (React.isValidElement(component)) {
          output.content = React.cloneElement(component, { closeTooltip: closeTooltip });
        } else {
          output.content = component({ closeTooltip: closeTooltip });
        }
      } else {
        output.content = React.createElement(TooltipContainer, this.props);
      }

      if (!hideArrow) {
        output.arrow = React.createElement(Arrow, this.props);
      }

      return React.createElement(
        'div',
        {
          ref: setTooltipRef,
          className: '__tooltip',
          style: this.tooltipStyle
        },
        output.content,
        output.arrow
      );
    }
  }, {
    key: 'tooltipStyle',
    get: function get$$1() {
      var _props2 = this.props,
          disableAnimation = _props2.disableAnimation,
          component = _props2.component,
          placement = _props2.placement,
          hideArrow = _props2.hideArrow,
          isPositioned = _props2.isPositioned,
          status = _props2.status,
          styles = _props2.styles;
      var length = styles.arrow.length,
          tooltip = styles.tooltip,
          tooltipCentered = styles.tooltipCentered,
          tooltipClosing = styles.tooltipClosing,
          tooltipOpening = styles.tooltipOpening,
          tooltipWithAnimation = styles.tooltipWithAnimation,
          tooltipWithComponent = styles.tooltipWithComponent;

      var element = {};

      if (!hideArrow) {
        if (placement.startsWith('top')) {
          element.padding = '0 0 ' + length + 'px';
        } else if (placement.startsWith('bottom')) {
          element.padding = length + 'px 0 0';
        } else if (placement.startsWith('left')) {
          element.padding = '0 ' + length + 'px 0 0';
        } else if (placement.startsWith('right')) {
          element.padding = '0 0 0 ' + length + 'px';
        }
      }

      if ([STATUS.OPENING, STATUS.OPEN].indexOf(status) !== -1) {
        element = _extends({}, element, tooltipOpening);
      }

      if (status === STATUS.CLOSING) {
        element = _extends({}, element, tooltipClosing);
      }

      if (status === STATUS.OPEN && !disableAnimation && !isPositioned) {
        element = _extends({}, element, tooltipWithAnimation);
      }

      if (placement === 'center') {
        element = _extends({}, element, tooltipCentered);
      }

      if (component) {
        element = _extends({}, element, tooltipWithComponent);
      }

      return _extends({}, tooltip, element);
    }
  }]);
  return Tooltip;
}(React.Component);

Tooltip.propTypes = {
  component: PropTypes.oneOfType([PropTypes.func, PropTypes.element]),
  content: PropTypes.node,
  disableAnimation: PropTypes.bool.isRequired,
  footer: PropTypes.node,
  handleClick: PropTypes.func.isRequired,
  hideArrow: PropTypes.bool.isRequired,
  isPositioned: PropTypes.bool,
  open: PropTypes.bool,
  placement: PropTypes.string.isRequired,
  positionWrapper: PropTypes.bool.isRequired,
  setArrowRef: PropTypes.func.isRequired,
  setTooltipRef: PropTypes.func.isRequired,
  showCloseButton: PropTypes.bool,
  status: PropTypes.string.isRequired,
  styles: PropTypes.object.isRequired,
  title: PropTypes.node
};

var Wrapper = function (_React$Component) {
  inherits(Wrapper, _React$Component);

  function Wrapper() {
    classCallCheck(this, Wrapper);
    return possibleConstructorReturn(this, (Wrapper.__proto__ || Object.getPrototypeOf(Wrapper)).apply(this, arguments));
  }

  createClass(Wrapper, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          handleClick = _props.handleClick,
          handleMouseEnter = _props.handleMouseEnter,
          handleMouseLeave = _props.handleMouseLeave,
          setChildRef = _props.setChildRef,
          setWrapperRef = _props.setWrapperRef,
          style = _props.style,
          styles = _props.styles;

      var element = void 0;

      /* istanbul ignore else */
      if (children) {
        if (React.Children.count(children) === 1) {
          if (!React.isValidElement(children)) {
            element = React.createElement(
              'span',
              null,
              children
            );
          } else {
            var refProp = is.function(children.type) ? 'innerRef' : 'ref';
            element = React.cloneElement(React.Children.only(children), defineProperty({}, refProp, setChildRef));
          }
        } else {
          element = children;
        }
      }

      if (!element) {
        return null;
      }

      return React.createElement(
        'span',
        {
          ref: setWrapperRef,
          style: _extends({}, styles, style),
          onClick: handleClick,
          onMouseEnter: handleMouseEnter,
          onMouseLeave: handleMouseLeave
        },
        element
      );
    }
  }]);
  return Wrapper;
}(React.Component);

Wrapper.propTypes = {
  children: PropTypes.node,
  handleClick: PropTypes.func.isRequired,
  handleMouseEnter: PropTypes.func.isRequired,
  handleMouseLeave: PropTypes.func.isRequired,
  setChildRef: PropTypes.func.isRequired,
  setWrapperRef: PropTypes.func.isRequired,
  style: PropTypes.object,
  styles: PropTypes.object.isRequired
};

var zIndex = 100;

var STYLES = {
  wrapper: {
    cursor: 'help',
    display: 'inline-flex',
    flexDirection: 'column',
    zIndex: zIndex
  },
  wrapperPosition: {
    left: -1000,
    position: 'absolute',
    top: -1000,
    visibility: 'hidden'
  },
  tooltip: {
    display: 'inline-block',
    filter: 'drop-shadow(0 0 3px rgba(0, 0, 0, 0.3))',
    maxWidth: 300,
    opacity: 0,
    position: 'relative',
    transition: 'opacity 0.3s',
    visibility: 'hidden',
    zIndex: zIndex
  },
  tooltipOpening: {
    opacity: 1,
    visibility: 'visible'
  },
  tooltipWithAnimation: {
    opacity: 1,
    transition: 'opacity 0.3s, transform 0.2s',
    visibility: 'visible'
  },
  tooltipWithComponent: {
    maxWidth: '100%'
  },
  tooltipClosing: {
    opacity: 0,
    visibility: 'visible'
  },
  tooltipCentered: {
    left: '50%',
    position: 'fixed',
    top: '50%',
    transform: 'translate(-50%, -50%)'
  },
  container: {
    backgroundColor: '#fff',
    color: '#666',
    minHeight: 60,
    minWidth: 200,
    padding: 20,
    position: 'relative'
  },
  title: {
    borderBottom: '1px solid #555',
    color: '#555',
    fontSize: 18,
    marginBottom: 5,
    paddingBottom: 6,
    paddingRight: 18
  },
  content: {
    fontSize: 15
  },
  close: {
    backgroundColor: 'transparent',
    border: 0,
    borderRadius: 0,
    color: '#555',
    fontSize: 0,
    height: 15,
    outline: 'none',
    padding: 10,
    position: 'absolute',
    right: 0,
    top: 0,
    width: 15,
    WebkitAppearance: 'none'
  },
  footer: {
    borderTop: '1px solid #ccc',
    fontSize: 13,
    marginTop: 10,
    paddingTop: 5
  },
  arrow: {
    color: '#fff',
    display: 'inline-flex',
    length: 16,
    position: 'absolute',
    spread: 32
  }
};

var POSITIONING_PROPS = ['position', 'top', 'right', 'bottom', 'left'];

var ReactTooltips = function (_React$Component) {
  inherits(ReactTooltips, _React$Component);

  function ReactTooltips(props) {
    classCallCheck(this, ReactTooltips);

    /* istanbul ignore else */
    var _this = possibleConstructorReturn(this, (ReactTooltips.__proto__ || Object.getPrototypeOf(ReactTooltips)).call(this, props));

    _initialiseProps.call(_this);

    

    _this.state = {
      currentPlacement: props.placement,
      positionWrapper: props.wrapperOptions.position && !!props.target,
      status: STATUS.INIT,
      statusWrapper: STATUS.INIT
    };
    return _this;
  }

  createClass(ReactTooltips, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!canUseDOM) return;
      var positionWrapper = this.state.positionWrapper;
      var _props = this.props,
          children = _props.children,
          open = _props.open,
          target = _props.target;


      log({
        title: 'init',
        data: {
          hasChildren: !!children,
          hasTarget: !!target,
          isControlled: is.boolean(open),
          positionWrapper: positionWrapper,
          target: this.target,
          tooltip: this.tooltipRef
        },
        debug: this.debug
      });

      this.initPopper();

      if (!children && target && !is.boolean(open)) {
        // add event listener based on event,
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!canUseDOM) return;

      var _props2 = this.props,
          open = _props2.open,
          target = _props2.target,
          wrapperOptions = _props2.wrapperOptions;


      if (open !== nextProps.open) {
        this.toggle();
      }

      if (wrapperOptions.position !== nextProps.wrapperOptions.position || target !== nextProps.target) {
        this.changeWrapperPosition(nextProps);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (!canUseDOM) return;

      var _props3 = this.props,
          autoOpen = _props3.autoOpen,
          open = _props3.open;

      var _comparator = comparator(prevState, this.state),
          changedFrom = _comparator.changedFrom,
          changedTo = _comparator.changedTo;

      if (changedTo('status', STATUS.IDLE) && open) {
        this.toggle(STATUS.OPEN);
      } else if (changedFrom('status', STATUS.INIT, STATUS.IDLE) && autoOpen) {
        this.toggle(STATUS.OPEN);
      }

      if (this.tooltipRef && (changedTo('status', STATUS.OPENING) || changedTo('status', STATUS.CLOSING))) {
        once(this.tooltipRef, 'transitionend', this.handleTransitionEnd);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (!canUseDOM) return;

      if (this.popper) {
        this.popper.instance.destroy();
      }

      if (this.wrapperPopper) {
        this.wrapperPopper.instance.destroy();
      }
    }
  }, {
    key: 'initPopper',
    value: function initPopper() {
      var _this2 = this;

      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.target;
      var positionWrapper = this.state.positionWrapper;
      var _props4 = this.props,
          disableFlip = _props4.disableFlip,
          getPopper = _props4.getPopper,
          hideArrow = _props4.hideArrow,
          offset = _props4.offset,
          placement = _props4.placement,
          wrapperOptions = _props4.wrapperOptions;

      var flipBehavior = placement === 'top' || placement === 'bottom' ? 'flip' : ['right', 'bottom-end', 'top-end', 'left', 'top-start', 'bottom-start'];

      /* istanbul ignore else */
      if (placement === 'center') {
        this.setState({ status: STATUS.IDLE });
      } else if (target && this.tooltipRef) {
        new Popper(target, this.tooltipRef, {
          placement: placement,
          modifiers: {
            arrow: _extends({
              enabled: !hideArrow,
              element: this.arrowRef
            }, this.options.arrow),
            computeStyle: this.options.computeStyle,
            flip: _extends({
              enabled: !disableFlip,
              behavior: flipBehavior
            }, this.options.flip),
            keepTogether: this.options.keepTogether,
            hide: this.options.hide,
            inner: this.options.inner,
            offset: _extends({
              offset: '0, ' + offset + 'px'
            }, this.options.offset),
            preventOverflow: this.options.preventOverflow,
            shift: this.options.shift
          },
          onCreate: function onCreate(data) {
            _this2.popper = data;

            getPopper(data, 'tooltip');

            _this2.setState({
              currentPlacement: data.placement,
              status: STATUS.IDLE
            });

            if (placement !== data.placement) {
              setTimeout(function () {
                data.instance.update();
              }, 1);
            }
          },
          onUpdate: function onUpdate(data) {
            _this2.popper = data;

            if (data.placement !== _this2.state.currentPlacement) {
              _this2.setState({ currentPlacement: data.placement });
            }
          }
        });
      }

      if (positionWrapper) {
        var wrapperOffset = !is.undefined(wrapperOptions.offset) ? wrapperOptions.offset : 0;

        new Popper(this.target, this.wrapperRef, {
          placement: wrapperOptions.placement || placement,
          modifiers: {
            arrow: {
              enabled: false
            },
            offset: {
              offset: '0, ' + wrapperOffset + 'px'
            },
            flip: {
              enabled: false
            }
          },
          onCreate: function onCreate(data) {
            _this2.wrapperPopper = data;
            _this2.setState({ statusWrapper: STATUS.IDLE });

            getPopper(data, 'wrapper');

            if (placement !== data.placement) {
              setTimeout(function () {
                data.instance.update();
              }, 1);
            }
          }
        });
      }
    }
  }, {
    key: 'changeWrapperPosition',
    value: function changeWrapperPosition(_ref) {
      var target = _ref.target,
          wrapperOptions = _ref.wrapperOptions;

      this.setState({
        positionWrapper: wrapperOptions.position && !!target
      });
    }
  }, {
    key: 'toggle',
    value: function toggle(forceStatus) {
      var status = this.state.status === STATUS.OPEN ? STATUS.CLOSING : STATUS.OPENING;

      if (!is.undefined(forceStatus)) {
        status = forceStatus;
      }

      this.setState({ status: status });
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          currentPlacement = _state.currentPlacement,
          positionWrapper = _state.positionWrapper,
          status = _state.status;
      var _props5 = this.props,
          children = _props5.children,
          component = _props5.component,
          content = _props5.content,
          disableAnimation = _props5.disableAnimation,
          footer = _props5.footer,
          hideArrow = _props5.hideArrow,
          open = _props5.open,
          showCloseButton = _props5.showCloseButton,
          style = _props5.style,
          title = _props5.title;


      var wrapper = React.createElement(
        Wrapper,
        {
          handleClick: this.handleClick,
          handleMouseEnter: this.handleMouseEnter,
          handleMouseLeave: this.handleMouseLeave,
          setChildRef: this.setChildRef,
          setWrapperRef: this.setWrapperRef,
          style: style,
          styles: this.styles.wrapper
        },
        children
      );

      var output = {};

      if (positionWrapper) {
        output.wrapperInPortal = wrapper;
      } else {
        output.wrapperAsChildren = wrapper;
      }

      return React.createElement(
        'span',
        null,
        React.createElement(
          Portal,
          _extends({}, this.props, {
            hasChildren: !!children,
            placement: currentPlacement,
            setRef: this.setTooltipRef,
            status: status
          }),
          React.createElement(Tooltip, {
            component: component,
            content: content,
            disableAnimation: disableAnimation,
            footer: footer,
            handleClick: this.handleClick,
            hideArrow: hideArrow || currentPlacement === 'center',
            isPositioned: !!this.position,
            open: open,
            placement: currentPlacement,
            positionWrapper: positionWrapper,
            setArrowRef: this.setArrowRef,
            setTooltipRef: this.setTooltipRef,
            showCloseButton: showCloseButton,
            status: status,
            styles: this.styles,
            title: title
          }),
          output.wrapperInPortal
        ),
        output.wrapperAsChildren
      );
    }
  }, {
    key: 'debug',
    get: function get$$1() {
      return this.props.debug || !!global.ReactTooltipsDebug;
    }
  }, {
    key: 'event',
    get: function get$$1() {
      var _props6 = this.props,
          disableHoverToClick = _props6.disableHoverToClick,
          event = _props6.event;


      if (event === 'hover' && isMobile() && !disableHoverToClick) {
        return 'click';
      }

      return event;
    }
  }, {
    key: 'options',
    get: function get$$1() {
      var options = this.props.options;


      return deepmerge(DEFAULTS, options || {});
    }
  }, {
    key: 'styles',
    get: function get$$1() {
      var _this3 = this;

      var _state2 = this.state,
          status = _state2.status,
          positionWrapper = _state2.positionWrapper,
          statusWrapper = _state2.statusWrapper;
      var styles = this.props.styles;


      var nextStyles = deepmerge(STYLES, styles);

      if (positionWrapper) {
        var wrapperStyles = void 0;

        if (!([STATUS.IDLE].indexOf(status) !== -1) || !([STATUS.IDLE].indexOf(statusWrapper) !== -1)) {
          wrapperStyles = nextStyles.wrapperPosition;
        } else {
          wrapperStyles = this.wrapperPopper.styles;
        }

        nextStyles.wrapper = _extends({}, nextStyles.wrapper, wrapperStyles);
      }

      /* istanbul ignore else */
      if (this.target) {
        var targetStyles = window.getComputedStyle(this.target);

        /* istanbul ignore else */
        if (this.wrapperStyles) {
          nextStyles.wrapper = _extends({}, nextStyles.wrapper, this.wrapperStyles);
        } else if (!(['relative', 'static'].indexOf(targetStyles.position) !== -1)) {
          this.wrapperStyles = {};

          if (!positionWrapper) {
            if (!this.position) {
              this.position = targetStyles.position;
            }

            POSITIONING_PROPS.forEach(function (d) {
              _this3.wrapperStyles[d] = targetStyles[d];
            });

            nextStyles.wrapper = _extends({}, nextStyles.wrapper, this.wrapperStyles);

            this.target.style.position = 'relative';
            this.target.style.top = 'auto';
            this.target.style.right = 'auto';
            this.target.style.bottom = 'auto';
            this.target.style.left = 'auto';
          }
        }
      }

      return nextStyles;
    }
  }, {
    key: 'target',
    get: function get$$1() {
      var target = this.props.target;


      if (target) {
        if (is.domElement(target)) {
          return target;
        }

        return document.querySelector(target);
      }

      return this.childRef || this.wrapperRef;
    }
  }]);
  return ReactTooltips;
}(React.Component);

ReactTooltips.propTypes = {
  autoOpen: PropTypes.bool,
  callback: PropTypes.func,
  children: PropTypes.node,
  component: isRequiredIf(PropTypes.oneOfType([PropTypes.func, PropTypes.element]), function (props) {
    return !props.content;
  }),
  content: isRequiredIf(PropTypes.node, function (props) {
    return !props.component;
  }),
  debug: PropTypes.bool,
  disableAnimation: PropTypes.bool,
  disableFlip: PropTypes.bool,
  disableHoverToClick: PropTypes.bool,
  event: PropTypes.oneOf(['hover', 'click']),
  eventDelay: PropTypes.number,
  footer: PropTypes.node,
  getPopper: PropTypes.func,
  hideArrow: PropTypes.bool,
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  offset: PropTypes.number,
  open: PropTypes.bool,
  options: PropTypes.object,
  placement: PropTypes.oneOf(['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end', 'auto', 'center']),
  showCloseButton: PropTypes.bool,
  style: PropTypes.object,
  styles: PropTypes.object,
  target: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  title: PropTypes.node,
  wrapperOptions: PropTypes.shape({
    placement: PropTypes.oneOf(['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end', 'auto']),
    position: PropTypes.bool,
    offset: PropTypes.number
  })
};
ReactTooltips.defaultProps = {
  autoOpen: false,
  callback: noop,
  debug: false,
  disableAnimation: false,
  disableFlip: false,
  disableHoverToClick: false,
  event: 'click',
  eventDelay: 0.4,
  getPopper: noop,
  hideArrow: false,
  offset: 15,
  placement: 'bottom',
  showCloseButton: false,
  styles: {},
  target: null,
  wrapperOptions: {
    position: false
  }
};

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.setArrowRef = function (ref) {
    _this4.arrowRef = ref;
  };

  this.setChildRef = function (ref) {
    _this4.childRef = ref;
  };

  this.setTooltipRef = function (ref) {
    if (!_this4.tooltipRef) {
      _this4.tooltipRef = ref;
    }
  };

  this.setWrapperRef = function (ref) {
    _this4.wrapperRef = ref;
  };

  this.handleTransitionEnd = function () {
    var callback = _this4.props.callback;

    /* istanbul ignore else */

    if (_this4.wrapperPopper) {
      _this4.wrapperPopper.instance.update();
    }

    _this4.setState({
      status: _this4.state.status === STATUS.OPENING ? STATUS.OPEN : STATUS.IDLE
    }, function () {
      callback(_this4.state.status === STATUS.OPEN ? 'open' : 'close', _this4.props);
    });
  };

  this.handleClick = function () {
    if (is.boolean(_this4.props.open)) return;

    var status = _this4.state.status;

    /* istanbul ignore else */

    if (_this4.event === 'click') {
      log({
        title: 'click',
        data: [{ event: _this4.props.event, status: status === STATUS.OPEN ? 'closing' : 'opening' }],
        debug: _this4.debug
      });

      _this4.toggle();
    }
  };

  this.handleMouseEnter = function () {
    if (is.boolean(_this4.props.open) || isMobile()) return;
    var status = _this4.state.status;

    /* istanbul ignore else */

    if (_this4.event === 'hover' && status === STATUS.IDLE) {
      log({
        title: 'mouseEnter',
        data: [{ key: 'originalEvent', value: _this4.props.event }],
        debug: _this4.debug
      });

      clearTimeout(_this4.eventDelayTimeout);
      _this4.toggle();
    }
  };

  this.handleMouseLeave = function () {
    if (is.boolean(_this4.props.open) || isMobile()) return;

    var _props7 = _this4.props,
        event = _props7.event,
        eventDelay = _props7.eventDelay;
    var _state3 = _this4.state,
        status = _state3.status,
        positionWrapper = _state3.positionWrapper;

    /* istanbul ignore else */

    if (_this4.event === 'hover') {
      log({
        title: 'mouseLeave',
        data: [{ key: 'originalEvent', value: event }],
        debug: _this4.debug
      });

      if (!eventDelay) {
        _this4.toggle(STATUS.IDLE);
      } else if ([STATUS.OPENING, STATUS.OPEN].indexOf(status) !== -1 && !positionWrapper && !_this4.eventDelayTimeout) {
        _this4.eventDelayTimeout = setTimeout(function () {
          delete _this4.eventDelayTimeout;

          _this4.toggle();
        }, eventDelay * 1000);
      }
    }
  };
};

module.exports = ReactTooltips;
